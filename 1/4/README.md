# 21774 [바로가기](https://www.acmicpc.net/problem/21774)  [분석](https://codingdog.tistory.com/519)
로그가 기록된 파일이 있습니다. 이 때 시각 _t1_ 와 _t2_ 사이에 로그 레벨이 _lv_ 이상인 것이 몇 개 발생했는지 구해야 합니다.

---
## 왜 합불을 가르는 문항인가?
* 이미 유사한 기출 문제가 있습니다.
* 시각 처리, 누적합에 대해 출제된 것도 유사하다고 할 수 있습니다.

기출 분석을 제대로 했는지, 그렇지 않았는지 가르기 위해 출제하였습니다.

## 어떻게 접근해야 하는가?
조건을 먼저 봅시다.
* _lv_ 이 6 이하입니다. 
* _Q_ 의 개수가 20만개 이하입니다.
* 20만 * 6 * log(N)은 2000만 이하입니다.

결국 우리는 _Q_ 마다 __6log(N)__ 의 복잡도로 처리해도 됨을 알 수 있습니다. 무작정 해보는 방법부터 생각해 봅시다.
* 시각 1과 시각 2가 주어지면 시각 1부터 시각 2까지 돌립니다. 1초마다요.
  * 1년이 3000만초가 넘으니까, _Q_ 1번 돌려도 상당한 시간이 걸리겠군요.
* 혹은 _n_ 개의 로그들을 일일히 보면서 _t1_ 과 _t2_ 사이에 발생했는지 계산합니다.
  * 이 방법은 _Q_ 당 최대 6억번 loop를 도는 대신에 20만번으로 대폭 개선됩니다.
  * 그런데, _Q_ 가 최대 20만번이니, _NQ_ 의 복잡도면 터질 듯 하네요.

로그를 무지성으로 돌리는 것 보다 좋은 방법이 있을까요? 로그 기록은 지워지거나 없어지지 않는다는 것입니다. 따라서
* 2000년 1월 1일 0시 0분 0초부터, 대회가 일어난 시각까지
  * 로그가 몇 개 발생했는지를 저장합니다.
  * 그리고 이 횟수를 **누적** 합니다.

이 작업을 하면 어떻게 개선을 할 수 있을까요?
* 이제 우리는 _t1_ ~ _t2_ 사이에 발생한 로그를 
  * _t2_ 까지 발생한 로그 수에서
  * _t1_ - 1 까지 발생한 로그 수를 빼면 됩니다.

_lv_ 이상의 로그를 구해야 하므로, 로그가 발생한 정보는 _LOG[lv][time]_ 으로 저장하면 됩니다. 시각의 범위가 커지기 때문에 **좌표압축** 을 하면 되겠네요.

## 더 쉬운 풀이
시각 _t1_ 이 시각 _t2_ 보다 앞에 있다면, _t1_ 은 _t2_ 보다 사전순으로 앞에 있을 것입니다. 시각을 파싱하지 않고 **문자열** 로 보면 어떨까요? c++에서 _lower_bound_ 와 _upper_bound_ 함수가 있습니다.
* _lower_bound(s)_ 는, _s_ 와 같거나 큰 원소가 나오는 최초의 위치를 반환합니다.
* _upper_bound(s)_ 는, _s_ 보다 큰 원소가 나오는 최초의 위치를 반환합니다.

우리는 [t1, t2] 구간의 _log_ 갯수를 구하는 것입니다. 따라서
* _upper_bound(t2)_ 로, _t2_ 보다 큰 원소가 나오는 최초의 위치를 구합니다.
* _lower_bound(t1)_ 로, _t1_ 보다 같거나 큰 원소가 나오는 최초의 위치를 구합니다.

이 작업을 _LV_ 이상인 로그에 대해서 반복해 주면 됩니다. 발생 시각별로 **로그가 정렬** 되어 있으면 _binary search_ 로 찾을 수 있다는 것을 이용한 것입니다.